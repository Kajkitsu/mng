<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Metody i narzƒôdzia generowania kodu wykonywalnego</title>

	<meta name="description" content="MNGKW LAB">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-background-gradient="linear-gradient(45deg, #333, #1f7520)">
				<h2>Metody i narzƒôdzia generowania kodu wykonywalnego</h2>
				<br slyle="height: 600px;" />
				<p style="text-align: left;">ppor. mgr in≈º. Norbert Waszkowiak</p>
				<div class="fragment" style="text-align: left;">
					<small>nr tel.: 261 839 060</small>
					<br />
					<small>e-mail: norbert.waszkowiak@wat.edu.pl</small>
					<br />
					<small>pomieszczenie: bud. 100 pok. 254B</small>
					<br />
					<small>konsultacje online i stacjanarnie: po wcze≈õniejszym um√≥wieniu</small>
				</div>
			</section>
			<section data-background-gradient="linear-gradient(to bottom, #000, #9c0101)">
				<h2>Zasady oceniania</h2>
				<section>
					<small>
						<ol>
							<li>Ka≈ºde przedstawione zadanie podlega punktacji. W trakcie jednego spotkania mo≈ºna uzyskaƒá
								100punkt√≥w;</li>
							<li>W przypadku stwierdzenia niesamodzielno≈õci w wykonaniu pracy zostanie ona wliczona do
								≈õredniej
								jako 0pkt.</li>
							<li>Ostateczna ocena z laboratori√≥w bƒôdzie wynikiem liczny zebranych punkt√≥w, zgodnie z
								skalƒÖ:
								<ul>
									<li>0-50 pkt -> <b>2</b></li>
									<li>51-60 pkt -> <b>3</b></li>
									<li>61-70 pkt -> <b>3,5</b></li>
									<li>71-80 pkt -> <b>4</b></li>
									<li>81-90 pkt -> <b>4,5</b></li>
									<li>91-100 pkt -> <b>5</b></li>
								</ul>
							</li>
							<li>Obecno≈õƒá na wszystkich zajƒôciach jest obowiƒÖzkowa. Zaleg≈Ço≈õci mo≈ºna usunƒÖƒá uczestniczƒÖc
								w
								zajƒôciach z innƒÖ grupƒÖ, po wcze≈õniejszym poinformowaniu prowadzƒÖcego. W przypadku, gdy
								zajƒôcia z pozosta≈Çymi grupami ju≈º siƒô odby≈Çy, mo≈ºna odrobiƒá zajƒôcia na konsultacjach.
								Dopuszczalna liczba nieobecno≈õci: 1.</li>
							<li>Zajƒôcia bƒôdƒÖ realizowane z wykorzystaniem serwisu https://classroom.github.com/. Terminy
								wykonania zadania sƒÖ okre≈õlone w zadaniach.</li>
						</ol>
					</small>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(45deg, #c03090, #10a080)">
				<section>
					<h2>Wyra≈ºenia regularne</h2>
				</section>
				<section>
					<h3>A komu to potrzebne? A dlaczego? </h3>
					<small style="text-align: left;">Wyra≈ºenia regularne (ang. regular expression, w skr√≥cie regex lub
						regexp) - wzorzec
						opisujƒÖcy ≈Ça≈Ñcuch symboli. Teoria wyra≈ºe≈Ñ regularnych jest zwiƒÖzana z teoriƒÖ jƒôzyk√≥w
						regularnych.</small>
					<small style="text-align: left;"> Wyra≈ºenia regularne mogƒÖ okre≈õlaƒá zbi√≥r pasujƒÖcych ≈Ça≈Ñcuch√≥w, jak
						r√≥wnie≈º wyszczeg√≥lniaƒá istotne czƒô≈õci ≈Ça≈Ñcucha.</small>
				</section>
				<section>
					<small style="text-align: left;">W praktyce znalaz≈Çy bardzo szerokie zastosowanie, pozwalajƒÖ bowiem
						w
						≈Çatwy spos√≥b opisywaƒá wzorce tekstu, natomiast istniejƒÖce algorytmy w efektywny spos√≥b
						okre≈õlajƒÖ, czy podany ciƒÖg znak√≥w pasuje do wzorca lub wyszukujƒÖ w tek≈õcie wystƒÖpienia wzorca.
					</small>
					<small style="text-align: left;">Wyra≈ºenia regularne w praktycznych zastosowaniach sƒÖ zapisywane za
						pomocƒÖ bogatszej i ≈Çatwiejszej w u≈ºyciu sk≈Çadni ni≈º ta stosowana w rozwa≈ºaniach teoretycznych.
					</small>
				</section>
				<section>
					<h3>Pokaz z obja≈õnieniem</h3>
					<p><a href="https://regex101.com/r/1B5osM/1">Przyk≈Çad z grupami dzieka≈Ñskimi</a></p>
					<img src="assets/ss-regex.png" style="height: 500px;" />
					<p>Dane:</p>
					<small style="height: 1px; font-size: 6px;">WCY18IX1S3 ; WCY19IG1S1 ; WCY19IJ1N1 ;
						WCY19IJ1S1 ; WCY19IJ2S1 ; WCY19IJ3S1 ; WCY19IJ4S1 ; WCY19IL1S0 ; WCY19IT1S0 ; WCY19IW1S0 ;
						WCY19KA1S0 ; WCY19KB1S0 ; WCY19KC1S0 ; WCY19KC1S1 ; WCY19KS1S0 ; WCY19KS1S1 ; WCY20IG1S1 ;
						WCY20IJ1N1 ; WCY20IJ1S1 ; WCY20IJ2S1 ; WCY20IJ3S1 ; WCY20IM1S1 ; WCY20IX1S0 ; WCY20IX2S0 ;
						WCY20IX3S0 ; WCY20IX4S0 ; WCY20IX5S0 ; WCY20IX6S0 ; WCY20IY1S1 ; WCY20IY2S1 ; WCY20IY3S1 ;
						WCY20IY4S1 ; WCY20IY5S1 ; WCY20KA1S1 ; WCY20KC1S1 ; WCY20KX1S0 ; WCY20KX2S0 ; WCY20KX3S0 ;
						WCY20KX4S0 ; WCY20KY1S1 ; WCY20KY2S1 ; WCY20KY3S1 ; WCY21E71N5 ; WCY21I*BDa ; WCY21I*BDb ;
						WCY21I*SO ; WCY21I*Tpi ; WCY21IB1S4 ; WCY21IB2S4 ; WCY21IE1S4 ; WCY21IH1S4 ; WCY21IM1S4 ;
						WCY21IV1S4 ; WCY21IX1N1 ; WCY21IX1S0 ; WCY21IX2N1 ; WCY21IX2S0 ; WCY21IX3S0 ; WCY21IX4S0 ;
						WCY21IX5S0 ; WCY21IX6S0 ; WCY21IY1S1 ; WCY21IY2S1 ; WCY21IY3S1 ; WCY21IY4S1 ; WCY21K*SAa ;
						WCY21K*SAb ; WCY21KB1S4 ; WCY21KB2S4 ; WCY21KB3S4 ; WCY21KC1S4 ; WCY21KS1S4 ; WCY21KS2S4 ;
						WCY21KT1S4 ; WCY21KX1S0 ; WCY21KX2S0 ; WCY21KX3S0 ; WCY21KX4S0 ; WCY21KX5S0 ; WCY21KX6S0 ;
						WCY21KY1S1 ; WCY21KY2S1 ; WCY22IA2aS6 ; WCY22IA2bS6 ; WCY22IB1N2 ; WCY22IB2N2 ; WCY22IB3aS6
						; WCY22IB3bS6 ; WCY22IBOS6 ; WCY22IE3aS6 ; WCY22IE3bS6 ; WCY22IX1N1 ; WCY22IX1N5 ;
						WCY22IX1S0 ; WCY22IX2N1 ; WCY22IX2N5 ; WCY22IX2S0 ; WCY22IX3N1 ; WCY22IX3S0 ; WCY22IX4S0 ;
						WCY22IX5S0 ; WCY22IY1S1 ; WCY22IY2S1 ; WCY22IY3S1 ; WCY22IY4S1 ; WCY22IY5S1 ; WCY22IZ3aS6 ;
						WCY22IZ3bS6 ; WCY22KX1S0 ; WCY22KX2S0 ; WCY22KX3S0 ; WCY22KX4S0 ; WCY22KX5S0 ; WCY22KX6S0 ;
						WCY22KX7S0 ; WCY22KY1S1 ; WCY22KY2S1 ; WCY22SO3S6 ; WCY22X*BBDa ; WCY22X*BDa ; WCY22X*Fiz2a
						; WCY22X*Fiz2b ; WCY22X*M1a ; WCY22X*M2a ; WCY22X*M2b ; WCY22X*Md1a ; WCY22X*TIiKa ;
						WME19BC1S1 ; WME19BM1S1 ; WME19BO1S1 ; WME20BE1S1 ; WME20BM1S1 ; WME20BO1S1 ; WME21BM1S4 ;
						WME21BX1S1 ; WME21BX2S1 ; WME21BX3S1 ; WME21BX4S1 ; WME22B1N5 ; WME22BX1S1 ; WME22BX2S1 ;
						WME22BX3S1 ; WME22BX4S1</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 i 2 üë®‚Äçüíª</h3>
					<p><a href="https://classroom.github.com/a/FVlMEpl_">Wyra≈ºenia reguralne w Pythonie</a></p>
					<p><a href="https://classroom.github.com/a/yBa0RZG0">Wyra≈ºenia reguralne w Javie</a></p>

				</section>
			</section>
			<section data-background-gradient="linear-gradient(20deg, #650000, #29448b)">
				<section>
					<h2>ANTLR4</h2>
				</section>
				<section>
					<h3>Co to jest i do czego s≈Çu≈ºy?</h3>
					<small>
						ANTLR (ang. ANother Tool for Language Recognition) to narzƒôdzie s≈Çu≈ºƒÖce do tworzenia
						kompilator√≥w oraz translator√≥w z opisu gramatyki, zawierajƒÖce akcje w jƒôzyku Java, C++, C# lub
						Python.
					</small>
					<small>
						Domy≈õlnie ANTLR generuje lekser i parser w Javie, a plik z gramatykƒÖ ma rozszerzenie
						<em>.g4</em>.
						Dostƒôpne sƒÖ r√≥wnie≈º implementacje narzƒôdzia w <a
							href="https://www.antlr.org/download.html">innych
							jƒôzykach</a>.
					</small>
					<small>Drzewo syntaktyczne dla dowolnej gramatyki mo≈ºna wygenerowaƒá r√≥wnie≈º za pomocƒÖ narzƒôdzia
						online <a href="http://lab.antlr.org/">ANTLR LAB</a>.</small>
					<div style="margin-top: 20px;"></div>
					<small>
						<a ref="https://github.com/antlr/antlr4/tree/master/doc">Dokumentacja ANTLR4</a>
					</small>
				</section>
				<section>
					<h3>Gramatyka kalkulatora</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code data-trim data-line-numbers="1|3|4|6-10">
						grammar Calculator;

						expression: integralExpression ((PLUS | MINUS) integralExpression)*;
						integralExpression: MINUS INT | INT;
						
						INT: [0-9]+ ;
						PLUS: '+' ;
						MINUS: '-' ;
						INTEGRAL: 'cal';
						WS : [ \t\r\n]+ -> skip ;
					</code></pre>
				</section>
				<section>
					<h3>Przydatne komendy</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs bash" data-trim data-line-numbers="1-2|4-5|7-8|10-12">
						#pobranie antlr jako jar 
						wget https://www.antlr.org/download/antlr-4.11.1-complete.jar
						
						#generowanie klas lexera i parsera
						java -jar ./antlr-4.11.1-complete.jar Calculator.g4

						#kompilowanie do bytecodu klas Calculator*
						javac -cp ./antlr-4.11.1-complete.jar Calculator*.java

						#podglƒÖd drzewa syntaktycznego
						java -cp .:antlr-4.11.1-complete.jar org.antlr.v4.gui.TestRig \
							Calculator expression -tree -gui example.txt
					</code></pre>
				</section>
				<section>
					<h3>Fragment kodu</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java"  data-trim data-line-numbers="1-5|7-9|11-22">
											
						public static void main(String[] args) throws Exception {
							CharStream charStreams = CharStreams.fromFileName("./example.txt");
							Integer result = calc(charStreams);
							System.out.println("Result = " + result);
						}

						public static Integer calc(String expression) {
							return calc(CharStreams.fromString(expression));
						}

						public static Integer calc(CharStream charStream) {
							CalculatorLexer lexer = new CalculatorLexer(charStream);
							CommonTokenStream tokens = new CommonTokenStream(lexer);
					
							CalculatorParser parser = new CalculatorParser(tokens);
							ParseTree tree = parser.expression();
					
							ParseTreeWalker walker = new ParseTreeWalker();
							CalculatorMainListener mainListener = new CalculatorMainListener();
							walker.walk(mainListener, tree);
							return mainListener.getResult();
						}
					</code></pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2</h3>
					<small style="text-align: left; margin: 30px;">
						Utworz publiczne
						repozytorium na github.com i umie≈õƒá link w
						<a href="https://forms.office.com/r/KKds3hSuv4">formularzu.</a>
						<br style="margin: 10px;" />
						Opracuj gramatykƒô kalkulatora, wygeneruj Lexer
						i Parser, a nastƒôpnie zaimplementuj jego
						dzia≈Çanie, rozszerzajƒÖc wybranƒÖ klasƒô, np. *BaseListener lub *BaseVisitor.
						<br style="margin: 10px;" />
						Wymagana funkcjonalno≈õci to: dodawanie,
						odejmowanie, mno≈ºenie, dzielenie, potƒôgowanie,
						pierwiastkowanie, zgodnie z kolejno≈õciƒÖ wykonywania dzia≈Ça≈Ñ.
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(45deg, #83be3c, #29448b)">
				<section>
					<h2>Bytecode</h2>
				</section>
				<section>
					<h3>javac</h3>
					<small>
						<em><b>javac</b></em> - jest to kompilator jƒôzyka Java, kt√≥ry przetwarza kod ≈∫r√≥d≈Çowy
						napisany w jƒôzyku Java na kod bajtowy. Umo≈ºliwia r√≥wnie≈º wykrywanie b≈Çƒôd√≥w sk≈Çadniowych oraz
						semantycznych w kodzie ≈∫r√≥d≈Çowym. Przyk≈Çadowe u≈ºycie <em><b>javac Example.java</b></em>. Javac
						oferuje szereg opcji kompilacji, takich jak ustawienia ≈õcie≈ºek klas, tryb debugowania czy wyb√≥r
						wersji Javy, do kt√≥rej ma byƒá skompilowany kod ≈∫r√≥d≈Çowy.
					</small>
				</section>
				<section>
					<h3>javac</h3>
					<small>
						<em><b>javac</b></em> - jest to kompilator jƒôzyka Java, kt√≥ry przetwarza kod ≈∫r√≥d≈Çowy
						napisany w jƒôzyku Java na kod bajtowy. Umo≈ºliwia r√≥wnie≈º wykrywanie b≈Çƒôd√≥w sk≈Çadniowych oraz
						semantycznych w kodzie ≈∫r√≥d≈Çowym. Przyk≈Çadowe u≈ºycie <em><b>javac Example.java</b></em>. Javac
						oferuje szereg opcji kompilacji, takich jak ustawienia ≈õcie≈ºek klas, tryb debugowania czy wyb√≥r
						wersji Javy, do kt√≥rej ma byƒá skompilowany kod ≈∫r√≥d≈Çowy.
					</small>
					<br style="margin: 30px;" />
					<small>IstniejƒÖ inne jƒôzyki programowania, kt√≥re zachowujƒÖ zgodno≈õƒá z jƒôzykiem Java, dlatego ≈ºe sƒÖ
						one wykonywane na JVM. Np. Kotlin, Scala, Groovy. Wszystkie one kompilujƒÖ siƒô do bytecodu,
						kt√≥rego forma nie r√≥≈ºni siƒô szczeg√≥lnie, wzglƒôdem tego, co zostanie wygenerowane przez javac.
					</small>
				</section>
				<section>
					<h3>
						Kompilatory JIT (Just-In-Time)
					</h3>
					<small>
						C1 i C2 to dwa rodzaje kompilator√≥w JIT (Just-In-Time) u≈ºywane w wirtualnej maszynie Javy (JVM).
						C1 jest kompilatorem szybkiego uruchamiania (ang. client), kt√≥ry skupia siƒô na szybkim
						uruchamianiu aplikacji i optymalizacji kodu na poczƒÖtku jego dzia≈Çania. C2 jest kompilatorem
						serwerowym (ang. server), kt√≥ry skupia siƒô na uzyskaniu jak najlepszej wydajno≈õci poprzez
						dog≈ÇƒôbnƒÖ analizƒô kodu i zoptymalizowanie go do granic mo≈ºliwo≈õci. W starszych wersjach Javy,
						u≈ºytkownik musia≈Ç rƒôcznie wybieraƒá miƒôdzy tymi dwoma kompilatorami, ale w Javie 7 wprowadzono
						tzw. kompilacjƒô stopniowanƒÖ (ang. tiered compilation), kt√≥ra umo≈ºliwia wykorzystanie obu
						kompilator√≥w w jednej aplikacji, tak aby uzyskaƒá jak najlepsze wyniki wydajno≈õciowe.
					</small>
				</section>
				<section>
					<h3>JIT w procesie uruchamiania aplikacji</h3>
					<img src="assets/JIT.png" />
				</section>
				<section>
					<h3>JIT w procesie uruchamiania aplikacji</h3>
					<small>
						Podczas wykonywania kodu przez JVM, nie zaczyna ona natychmiast kompilowaƒá kodu. IstniejƒÖ dwa
						powody:
						<ul>
							<li>
								Po pierwsze, je≈õli kod zostanie wykonany tylko raz, to jego kompilacja jest praktycznie
								marnowaniem mocy obliczeniowej. Szybsze jest interpretowanie bytecode'u ni≈º jego
								kompilowanie i wykonywanie
								skompilowanego kodu (tylko raz).
							</li>
							<li>
								Po drugie, im wiƒôcej razy JVM wykonuje danƒÖ metodƒô lub pƒôtlƒô, tym wiƒôcej informacji ma o
								tym jak zachowuje siƒô dany kod. Pozwala to na dokonywanie licznych optymalizacji przy
								kompilacji kodu w trakcie dzia≈Çania. JVM tworzy
								skompilowany kod, kt√≥ry radzi sobie z pewnymi niepewno≈õciami, co wiƒÖ≈ºe siƒô z
								deoptymalizacjƒÖ, a
								nastƒôpnie reoptymalizuje kodu.
							</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>
						Zamiana na stosie (OSR - on-stack replacement)
					</h3>
					<small>
						Kompilacja JIT jest procesem asynchronicznym: W czasie gdy JVM decyduje, kt√≥ra metoda powinna
						zostaƒá skompilowana, jest ona umieszczana w kolejce. Zamiast czekaƒá na kompilacje, JVM
						interpretujƒô metodƒô, ale za nastƒôpnym razem, gdy metoda zostanie wywo≈Çana kolejny razy, JVM
						bƒôdzie
						m√≥g≈Ç wykonaƒá jej skompilowanƒÖ wersje. To samo dotyczy siƒô r√≥wnie≈º pƒôtli. Wprzypadku, gdy pƒôtla
						jest d≈Çugo wykonana, r√≥wnie≈º ona trafia do kolejki. JVM jednak nie mo≈ºe czekaƒá, a≈º zostanie ona
						skompilowana i kontynuujƒô, interpretujƒÖc danƒÖ iteracje. Gdy tylko kod dla pƒôtli zostanie
						skompilowany, zostanie
						on podmieniony na stosie, a nastƒôpna iteracja skorzysta z du≈ºo szybszej skompilowanej wersji
						kodu. Taki proces nazywa siƒô zamianƒÖ na stosie (OSR - on-stack replacement).
					</small>
				</section>
				<section>
					<h3>
						Kompilacja stopniowa
					</h3>
					<small>
						Kompilator JIT kiedy≈õ mia≈Ç dwie wersje: kompilator klienta i serwera. Jak nazwa wskazuje,
						kompilator klienta (C1) jest u≈ºywany do aplikacji po stronie klienta, podczas gdy kompilator
						serwera (C2) jest u≈ºywany do aplikacji po stronie serwera. G≈Ç√≥wna r√≥≈ºnica miƒôdzy tymi dwoma
						kompilatorami polega na ich agresywno≈õci w kompilowaniu kodu. Kompilator C1 zaczyna kompilowaƒá
						szybciej ni≈º C2. Oznacza to, ≈ºe na poczƒÖtku wykonywania kodu, kompilator C1 bƒôdzie szybszy.
						Jednak≈ºe, kompilator C2 robi lepsze optymalizacje w skompilowanym kodzie, wykorzystujƒÖc wiedzƒô,
						kt√≥rƒÖ zdobywa podczas oczekiwania. Ostatecznie, kod produkowany przez kompilator C2 bƒôdzie
						szybszy ni≈º ten produkowany przez kompilator C1. Kompilacja stopniowa (tiered compilation)
						wchodzi w grƒô poprzez zastosowanie przez JVM kompilatora C1 na poczƒÖtku i przej≈õcie na
						kompilator C2, gdy kod staje siƒô bardziej "gorƒÖcy".
					</small>
				</section>
				<section>
					<h3>Optymalizacja JIT</h3>
					<small>
						<ul>
							<li>
								Inlining - polega na zamianie wywo≈Çania metody na wstawienie jej kodu bezpo≈õrednio w
								miejsce wywo≈Çania, co pozwala na oszczƒôdzenie czasu potrzebnego na wywo≈Çanie metody oraz
								zmniejszenie narzutu zwiƒÖzanego z przekazywaniem argument√≥w.
							</li>
							<li>
								Loop unrolling - polega na rozwiniƒôciu pƒôtli, czyli zastƒÖpieniu jej wielokrotnym
								powtarzaniem kodu, co pozwala na zmniejszenie narzutu zwiƒÖzanego z pƒôtlƒÖ.
							</li>
							Eliminacja niepotrzebnych warunk√≥w - polega na usuniƒôciu warunk√≥w, kt√≥re zawsze zwracajƒÖ
							true lub false, co pozwala na zmniejszenie narzutu zwiƒÖzanego z ich wykonywaniem.
							</li>
							<li>
								Dead code elimination - polega na usuwaniu kodu, kt√≥ry nigdy nie jest wykonywany, co
								pozwala na zmniejszenie rozmiaru kodu oraz przyspieszenie jego dzia≈Çania.
							</li>
							<li>
								Branch predicting - polega na przewidywaniu warunk√≥w logicznych (branch) w kodzie
								programu i podejmowania decyzji, kt√≥rej ga≈Çƒôzi nale≈ºy siƒô spodziewaƒá, zanim warunek
								zostanie faktycznie wykonany.
							</li>
						</ul>
						<br />
						<br />
						JIT r√≥wnie≈º wykorzystuje informacje o typach zmiennych w trakcie kompilacji do bardziej
						efektywnego generowania kodu. Na przyk≈Çad, je≈õli JIT wie, ≈ºe zmienna jest typu int, to mo≈ºe
						wygenerowaƒá kod, kt√≥ry operuje na tej zmiennej w bardziej zoptymalizowany spos√≥b ni≈º w przypadku
						zmiennej typu og√≥lnego Object.
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 üë®‚Äçüíª</h3>

					<small>
						<ul>
							<li>Napisz kod realizujƒÖcy prosty algorytm (minimum: 1 metoda, 1 instrukcja
								warunkowa, 1 pƒôtla) np. realizujƒÖcy sortowanie bƒÖbelkowe.</li>
							<li>Skompiluj kod (np. <em><b>javac
										Example.java</b></em> ), a nastƒôpnie (np. javap -c -s -constans Example.class)
								wy≈õwietl bytecode utworzonego algorytmu.</li>
							<li>Posi≈ÇkujƒÖc siƒô informacjami
								dostƒôpnymi w internecie np. <a
									href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">List_of_Java_bytecode_instructions</a>,
								opisz dok≈Çadnie wygenerowany kod.</li>
							<li>Nastƒôpnie taki sam algorytm zaimplementuj w innym jƒôzyku wykorzystujƒÖcym JVM, np.
								Kotlin.
								Wygeneruj bytecode i por√≥wnaj go z wcze≈õniej wygenerowanym kodem. Opisz r√≥≈ºnice, je≈ºeli
								wystƒôpujƒÖ.</li>
						</ul>
						<br />
						<br />
						Do ko≈Ñca trwania laboratori√≥w prze≈õlij za pomocƒÖ <a
							href="https://forms.office.com/r/2vbjxfX0fV">formularza</a>
						link do utworzonego <b>publicznego</b> repozytorium na github.com
					</small>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(60deg, #ae9852, #a3548b)">
				<section>
					<h2>Script engine</h2>
				</section>
				<section>
					<h3>A komu to potrzebne? A dlaczego?</h3>
					<small style="text-align: left; margin: 20px;">Script Engine to interpretator jƒôzyka programowania
						komputerowego, kt√≥rego funkcjƒÖ jest interpretacja tekstu program√≥w pochodzƒÖcego od u≈ºytkownik√≥w,
						t≈Çumaczenie takiego tekstu na kod maszynowy wykonywalny przez komputery oraz realizacja szeregu
						funkcji.
					</small>

					<small style="text-align: left; margin: 20px;">W praktyce jest on wykorzystywany jako interfejs do
						wp≈Çywania w zaawansowany (nieprzewidziany w trakcie implementacji) spos√≥b w stan systemu
						informatycznego. Przyk≈Çadowo jest to korekcja danych znajdujƒÖcych siƒô w systemie lub wywo≈Çywanie
						zada≈Ñ znajdujƒÖcych siƒô w harmonogramie (ang. scheduling) realizujƒÖcych np. integracje z
						systemami zewnƒôtrznymi.
					</small>
				</section>
				<section>
					<h3>GraalVM</h3>
					<small>GraalVM to maszyna wirtaulna oraz platforma stworzona przez firmƒô Oracle. Zapewnia ona
						≈õrodowisko uruchomieniowe dla wielu jƒôzyk√≥w programowania, takich jak Java, JavaScript, Python,
						Ruby, R oraz innych. G≈Ç√≥wnym celem GraalVM jest umo≈ºliwienie programistom korzystania z r√≥≈ºnych
						jƒôzyk√≥w programowania i integracji ich w jednym projekcie. Dziƒôki temu mo≈ºna pisaƒá aplikacje,
						kt√≥re wykorzystujƒÖ r√≥≈ºne jƒôzyki
						jednocze≈õnie, co daje wiƒôkszƒÖ elastyczno≈õƒá i umo≈ºliwia wyb√≥r najlepszego narzƒôdzia do
						konkretnego zadania.
					</small>
					<small>
						GraalVM oferuje tak≈ºe kompilacjƒô just-in-time (JIT) oraz ahead-of-time (AOT), co pozwala na
						optymalizacjƒô wydajno≈õci
						aplikacji. Dziƒôki temu programy uruchamiane na GraalVM mogƒÖ byƒá szybsze ni≈º te uruchamiane na
						tradycyjnych maszynach
						wirtualnych.
					</small>
				</section>

				<section>
					<h3>Pokaz z obja≈õnieniem</h3>
					<img src="assets/class_diagram.png" style="height: 700px;" />
				</section>
				<section data-auto-animate>
					<h2 data-id="code-title">Reprezentacja encji w bazie NOSQL</h2>
					<pre data-id="code-animation"><code data-trim data-line-numbers="1-14|6,11|17-28|22-26|9-14">
									//Journal
									{
										"id": "1",
										"baseScore": 100.0,
										"title": "Biuletyn WAT",
										"publisherId": "2",
										"issn": "1234-5865"
									}
									// Publisher
									{
										"id": "2",
										"name": "Wydawnictwo WAT",
										"location": "Warszawa",
									}
			
			
									//Journal with Publisher
									{
										"id": "1",
										"baseScore": 100.0,
										"title": "Biuletyn WAT",
										"publisher": {
											"id": "2",
											"name": "Wydawnictwo WAT",
											"location": "Warszawa",
										},
										"issn": "1234-5865"
									}
								</code></pre>
				</section>
				<section>
					<h2>üë®‚Äçüíª</h2>
					<h3>Live coding</h3>
					<small>Kod ≈∫r√≥d≈Çowy <a
							href="https://github.com/Kajkitsu/knowledge-mngkw/tree/clean_repo">tutaj</a>.</small>
				</section>

				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 4</h3>
					<span class="fragment">
						<p style="color: #ff2c2d;">
							Uwaga! Czas na wykonanie zadania: do ko≈Ñca trwania zajƒôƒá laboratoryjnych.
						</p>
					</span>
					<small style="margin: 10px;">Rozbuduj aplikacje Spring Boot, o endpoint umo≈ºliwiajƒÖcy
						wykonywanie skrypt√≥w,
						wykorzystujƒÖc narzƒôdzie GraalVM.
					</small>
					<small style="margin: 10px;">
						Opracuj skrypt rozwiƒÖzujƒÖcy zdefiniowany przez Ciebie problem. Skrypt wraz z opisem problemu
						zamie≈õƒá w README.md.
					</small>
					<small style="margin: 10px;">
						Do ko≈Ñca trwania laboratori√≥w nale≈ºy za pomocƒÖ <a
							href="https://forms.office.com/e/i5aNbeCt5U">formularza</a>
						przes≈Çaƒá link do <b>publicznego</b> repozytorium github.com, w kt√≥rym bƒôdzie opracowywane
						zadanie.
					</small>
					<small>
						Przyk≈Çadowy kod wraz z script engine <a
							href="https://github.com/Kajkitsu/knowledge-mngkw/tree/script_engine">na tym branachu</a>.
					</small>
				</section>
			</section>


		</div>

	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});

	</script>

</body>

</html>